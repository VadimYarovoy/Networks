== Функциональная схема приемника

Оптимальным алгоритмом приема, обеспечивающим минимум
вероятности ошибки, является алгоритм когерентного приема:

#math.equation(
  block: true,
  [$
    max_i [ integral_0^(T_a) x(t) s (beta_i, t)d t - 1/2 integral_0^(T_a) [s (beta_i, t)]^2 d t]
  $]
)

Где:

#math.equation(
  block: true,
  [$
    x(t) = s (beta_i, t) + n(t)
  $]
)

Формула после преобразований:

#math.equation(
  block: true,
  [$
    integral_0^(T_a) x(t) s (beta_i, t)d t > 0
  $]
)

Ожидаемые формы сигнала:

#math.equation(
  block: true,
  [$
    S_1(t) = A sin(2 pi f t), space
    S_0(t) = A sin(2 pi f t + pi)= - A sin(2 pi f t)
  $]
)

#pagebreak()
Когерентная схема приемника включает блок формирования согласованного сигнала с одинаковой фазой 
как у входящего сигнала. Алгоритм определяет фазу входящего сигнала и декодирует информацию. 
Дифференциальный декодер сравнивает последовательные фазовые решения: разные - символ 0, иначе 
символ 1. Система синхронизации поддерживает согласованность между передатчиком и приемником.

#figure(
  image("../pics/rx.png", width: 90%),
  caption: [
    Приемник
  ],
)

Схему выше можно упростить:
- нам достаточно знать только одну форму сигнала с генератора
- можно считать только один интеграл
- УВМ можно заменить на элемент $>$, так как у увм только 2 канала на входе 

#figure(
  image("../pics/rxs.png", width: 90%),
  caption: [
    Приемник оптимизированный
  ],
)

Далее будем рисовать диаграмы основываясь на первой схеме приемника для большей наглядности. Если бы рисовали по 2 схеме, то кол-во графиков сократилось бы в 2 раза.
#pagebreak()